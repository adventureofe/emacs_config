#+TITLE: Frogmacs Cofig
#+AUTHOR: AdventureOfE
#+DESCRIPTION: frogmacs config
#+STARTUP: overview

* STARTUP
#+BEGIN_SRC emacs-lisp
;; make garbage collection happen fewer times
  (setq gc-cons-threshold (* 100 1000 1000))
  
;;print startup info
(add-hook 'emacs-startup-hook
      #'(lambda ()
          (message "Startup in %s with %d garbage collections"
          (emacs-init-time "%.2f")
          gcs-done)))
#+END_SRC
* ELPACA
#+BEGIN_SRC emacs-lisp
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
								:ref nil :depth 1
								:files (:defaults "elpaca-test.el" (:exclude "extensions"))
								:build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
		 (build (expand-file-name "elpaca/" elpaca-builds-directory))
		 (order (cdr elpaca-order))
		 (default-directory repo))
	(add-to-list 'load-path (if (file-exists-p build) build repo))
	(unless (file-exists-p repo)
	  (make-directory repo t)
	  (when (< emacs-major-version 28) (require 'subr-x))
	  (condition-case-unless-debug err
		  (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
				   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
												   ,@(when-let ((depth (plist-get order :depth)))
													   (list (format "--depth=%d" depth) "--no-single-branch"))
												   ,(plist-get order :repo) ,repo))))
				   ((zerop (call-process "git" nil buffer t "checkout"
										 (or (plist-get order :ref) "--"))))
				   (emacs (concat invocation-directory invocation-name))
				   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
										 "--eval" "(byte-recompile-directory \".\" 0 'force)")))
				   ((require 'elpaca))
				   ((elpaca-generate-autoloads "elpaca" repo)))
			  (progn (message "%s" (buffer-string)) (kill-buffer buffer))
			(error "%s" (with-current-buffer buffer (buffer-string))))
		((error) (warn "%s" err) (delete-directory repo 'recursive))))
	(unless (require 'elpaca-autoloads nil t)
	  (require 'elpaca)
	  (elpaca-generate-autoloads "elpaca" repo)
	  (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

 ;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode)) 
#+END_SRC
* ABSOLUTE_ESSENTIALS_DEFAULTS
** MAKE ESC QUIT PROMPTS
#+BEGIN_SRC emacs-lisp
;; Make ESC quit prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC
** ZOOMING IN / OUT
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
(global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+END_SRC  
** DISABLE TOOLBARS
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)   
  (scroll-bar-mode -1)
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC
** INHIBIT_STARTUP_GUFF
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
#+END_SRC 
** CONSERVATIVE SCROLLING
#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100)
#+END_SRC 
** FANCY_LAMBDA_SYMBOLS_ETC
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
#+END_SRC
** TAB_WIDTH
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)

;; treat camelcase as separate words
(global-subword-mode 1)
#+END_SRC
** VISUAL_BELL
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
** TEMPORARY_THEME
#+BEGIN_SRC emacs-lisp
(load-theme 'manoj-dark)
#+END_SRC
* EXWM
#+BEGIN_SRC emacs-lisp
  (defun efs/run-in-background (command)
	  (let ((command-parts (split-string command "[ ]+")))
		  (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun efs/exwm-update-class ()
	  (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
	  (pcase exwm-class-name
		  ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))))

  (defun dw/exwm-init-hook ()
	  ;; Make workspace 1 be the one where we land at startup
	  (exwm-workspace-switch-create 1))

   (defun efs/configure-window-by-class ()
	   (interactive)
	   (pcase exwm-class-name
		  ("Firefox" (exwm-workspace-move-window 2))
		  ("Sol" (exwm-workspace-move-window 3))
		  ("mpv" (exwm-floating-toggle-floating)
		  (exwm-layout-toggle-mode-line))))

	;; This function should be used only after configuring autorandr!
	(defun efs/update-displays ()
		(efs/run-in-background "autorandr --change --force")
		(efs/set-wallpaper)
		(message "Display config: %s"
			(string-trim (shell-command-to-string "autorandr --current"))))

	(use-package exwm
	    :ensure t
	    :demand t
		:config
		(setq exwm-workspace-number 4)

		;; When window "class" updates, use it to set the buffer name
		(add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

		;; When window title updates, use it to set the buffer name
		(add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

		;; Configure windows as they're created
		(add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

		(setq exwm-input-prefixkeys
			'(?\C-x
			?\C-u
			?\C-h
			?\M-x
			?\M-`
			?\M-&
			?\M-:
			?\C-\M-j
			?\C-\ ))

		;;ctrl + q will enable the next key to be sent directly
		(define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

		(require 'exwm-randr)
		;; set workspaces to different screens
		(setq exwm-randr-workspace-monitor-plist '(1 "DVI-D-0"))
		(add-hook 'exwm-randr-screen-change-hook
			(lambda ()
				(start-process-shell-command "xrandr" nil "xrandr --output DVI-D-0 --left-of --output HDMI-0 --auto")))		
		(exwm-randr-enable)


		;; set workspaces to different screens
		(setq exwm-randr-workspace-monitor-plist '(2 "HDMI-0" 3 "HDMI-0"))

		;; Rebind CapsLock to Ctrl
		(start-process-shell-command "xmodmap" nil "xmodmap ~/.config/emacs/Xmodmap")


		;; Load the system tray before exwm-init
		(require 'exwm-systemtray)
		(setq exwm-systemtray-height 32)
		(exwm-systemtray-enable)

		(setq exwm-input-global-keys
			`(
				([?\s-r] . exwm-reset)
				([s-left] . windmove-left)
				([s-right]. windmove-right)
				([?\s-w] . exwm-workspace-switch)
				([?\s-&] . (lambda (command)
					(interactive (list (read-shell-command "$ ")))
					(start-process-shell-command command nil command)))

				;; Switch workspace
				([?\s-w] . exwm-workspace-switch)

				;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
				,@(mapcar (lambda (i)
					`(,(kbd (format "s-%d" i)) .
						(lambda ()
							(interactive)
							(exwm-workspace-switch-create ,i))))
					(number-sequence 0 9))))

		(exwm-enable))
#+END_SRC
* ABSOLUTE_ESSENTIALS_PACKAGES
I can't live without these. Putting these first in an attempt to have them load even if
something crashes in the config
** EVIL
#+BEGIN_SRC emacs-lisp
	;; Expands to: (elpaca evil (use-package evil :demand t))
	(use-package evil
	  :ensure t
	  :demand t
	  :init ;;tweak evil's config before loading
		(setq evil-want-integration t) ;; this is optional since already set to true
		(setq evil-want-keybinding nil)
		(setq evil-vsplit-window-right t)
		(setq evil-split-window-below t)
		 (setq evil-want-C-i-jump nil)
		(evil-mode) 
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state))

	 (use-package evil-collection
		:ensure t
		:demand t
		:after evil
		:config
		(setq evil-collection-mode-list '(dashboard dired ibuffer))
		(evil-collection-init))

	 (use-package evil-tutor
	   :ensure t
	   :demand t
	   :after evil
	   )
#+END_SRC
